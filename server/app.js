import express from 'express';import cors from 'cors';import helmet from 'helmet';import rateLimit from 'express-rate-limit';import fetch from 'node-fetch';import NodeCache from 'node-cache';import { promises as fs } from 'fs';import path from 'path';import { createHash, randomUUID, timingSafeEqual } from 'crypto';import pino from 'pino';import pinoHttp from 'pino-http';import compression from 'compression';import { DEFAULT_API_CACHE_TTL_SECONDS, MIN_API_CACHE_TTL_SECONDS, MAX_API_CACHE_TTL_SECONDS, DEFAULT_PRICE_CACHE_TTL_SECONDS, DEFAULT_PRICE_CACHE_CHECK_PERIOD_SECONDS, DEFAULT_MAX_STALE_TRADING_DAYS, RATE_LIMIT_DEFAULTS, MIN_RATE_LIMIT_WINDOW_MS, MIN_RATE_LIMIT_MAX, SECURITY_AUDIT_DEFAULT_MAX_EVENTS, PORTFOLIO_SCHEMA_VERSION, CASH_POLICY_SCHEMA_VERSION } from '../shared/constants.js';import { registerRateLimitConfig, recordRateLimitHit, getRateLimitMetrics } from './metrics/rateLimitMetrics.js';import { getPerformanceMetrics } from './metrics/performanceMetrics.js';import { runMigrations } from './migrations/index.js';import { runInterestAccrual, runInterestBackfill, previousTradingDay } from './jobs/interest.js';import { computeMoneyWeightedReturn, summarizeReturns } from './finance/returns.js';import { sortTransactions, weightsFromState } from './finance/portfolio.js';import { toDateKey } from './finance/cash.js';import {  d,  fromCents,  fromMicroShares,  roundDecimal,  toCents,  toMicroShares,} from './finance/decimal.js';import {  DualPriceProvider,  YahooPriceProvider,  StooqPriceProvider,} from './data/prices.js';import {  API_KEY_REQUIREMENTS,  apiKeySchema,  validateCashRateBody,  validatePortfolioBody,  validatePortfolioIdParam,  validateRangeQuery,  validateReturnsQuery,  validateInterestRunQuery,  validateInterestBackfillQuery,  validateSecurityEventsQuery,} from './middleware/validation.js';import { createSecurityAuditLogger } from './middleware/auditLog.js';import { createSecurityEventStore } from './security/eventsStore.js';import { atomicWriteFile } from './utils/atomicStore.js';import { withLock } from './utils/locks.js';import { computeTradingDayAge } from './utils/calendar.js';import {  configurePriceCache,  getCacheStats,  getCachedPrice,  setCachedPrice,} from './cache/priceCache.js';import {  configureBruteForce,  registerAuthFailure,  clearAuthFailures,  checkBruteForceLockout,  getBruteForceStats,} from './middleware/bruteForce.js';const DEFAULT_DATA_DIR = path.resolve(process.env.DATA_DIR ?? './data');const DEFAULT_FETCH_TIMEOUT_MS = Number.parseInt(  process.env.PRICE_FETCH_TIMEOUT_MS ?? '5000',  10,);const DEFAULT_LOGGER = pino({ level: process.env.LOG_LEVEL ?? 'info' });const DEFAULT_CACHE_TTL_SECONDS = (() => {  const raw = Number.parseInt(process.env.API_CACHE_TTL_SECONDS ?? String(DEFAULT_API_CACHE_TTL_SECONDS), 10);  if (!Number.isFinite(raw) || raw <= 0) {    return DEFAULT_API_CACHE_TTL_SECONDS;  }  return Math.max(MIN_API_CACHE_TTL_SECONDS, Math.min(MAX_API_CACHE_TTL_SECONDS, Math.round(raw)));})();const PORTFOLIO_ID_PATTERN = /^[A-Za-z0-9_-]{1,64}$/;const SYMBOL_PATTERN = /^[A-Za-z0-9._-]{1,32}$/;function createHttpError({  status = 500,  code = 'INTERNAL_ERROR',  message,  details,  expose,  requirements,}) {  const error = new Error(    message ?? (status >= 500 ? 'Unexpected server error' : 'Request could not be processed'),  );  error.status = status;  error.statusCode = status;  error.code = code;  if (details !== undefined) {    error.details = details;  }  if (Array.isArray(requirements)) {    error.requirements = requirements;  }  if (expose !== undefined) {    error.expose = expose;  } else {    error.expose = status < 500;  }  return error;}function adaptLogger(logger) {  if (!logger) {    return null;  }  if (typeof logger.child === 'function') {    return logger;  }  const safe = {    info(message, meta = {}) {      if (typeof logger.info === 'function') {        logger.info({ message, ...meta });      } else if (typeof logger.log === 'function') {        logger.log({ level: 'info', message, ...meta });      }    },    warn(message, meta = {}) {      if (typeof logger.warn === 'function') {        logger.warn({ message, ...meta });      } else if (typeof logger.log === 'function') {        logger.log({ level: 'warn', message, ...meta });      }    },    error(message, meta = {}) {      if (typeof logger.error === 'function') {        logger.error({ message, ...meta });      } else if (typeof logger.log === 'function') {        logger.log({ level: 'error', message, ...meta });      }    },    child() {      return safe;    },  };  return safe;}export function isValidPortfolioId(id) {  return PORTFOLIO_ID_PATTERN.test(id);}function filterRowsByRange(rows, from, to) {  return rows.filter((row) => {    if (from && row.date < from) {      return false;    }    if (to && row.date > to) {      return false;    }    return true;  });}function paginateRows(rows, { page = 1, perPage = 100 } = {}) {  const total = rows.length;  const normalizedPerPage = Number.isFinite(perPage) && perPage > 0 ? perPage : 100;  const totalPages = total === 0 ? 0 : Math.ceil(total / normalizedPerPage);  const safePage = totalPages === 0 ? Math.max(1, page) : Math.min(Math.max(1, page), totalPages);  const start = (safePage - 1) * normalizedPerPage;  const end = start + normalizedPerPage;  const items = rows.slice(start, end);  return {    items,    meta: {      page: safePage,      per_page: normalizedPerPage,      total,      total_pages: totalPages,    },  };}function computeEtag(serializedBody) {  return createHash('sha256').update(serializedBody).digest('base64url');}function sendJsonWithEtag(req, res, payload, { cacheControl } = {}) {  const serialized = JSON.stringify(payload);  const etag = computeEtag(serialized);  if (cacheControl) {    res.set('Cache-Control', cacheControl);  }  if (req.headers['if-none-match'] === etag) {    res.set('ETag', etag);    res.status(304).end();    return;  }  res.set('ETag', etag);  res.type('application/json').send(serialized);}export function createApp({  dataDir = DEFAULT_DATA_DIR,  fetchImpl = fetch,  logger = DEFAULT_LOGGER,  fetchTimeoutMs = DEFAULT_FETCH_TIMEOUT_MS,  config = null,  priceProvider = null,  auditSink = null,} = {}) {  const baseLogger = adaptLogger(logger) ?? DEFAULT_LOGGER;  const log = typeof baseLogger.child === 'function'    ? baseLogger.child({ module: 'app' })    : baseLogger;  const securityEventStore = createSecurityEventStore({ maxEvents: config?.security?.auditLog?.maxEvents ?? SECURITY_AUDIT_DEFAULT_MAX_EVENTS, });  const handleSecurityEvent = (event) => {    const stored = securityEventStore.record(event);    if (typeof auditSink === 'function') {      auditSink(stored ?? event);    }  };  const featureFlags = config?.featureFlags ?? { cashBenchmarks: true };  const allowedOrigins = config?.cors?.allowedOrigins ?? [];  const cacheTtlSeconds = (() => {    const override = config?.cache?.ttlSeconds;    if (Number.isFinite(override) && override > 0) {      return Math.round(override);    }    return DEFAULT_CACHE_TTL_SECONDS;  })();  const cacheControlHeader = `private, max-age=${cacheTtlSeconds}`;  const priceCacheConfig = config?.cache?.price ?? {};  const priceCacheTtlSeconds = Number.isFinite(priceCacheConfig.ttlSeconds)    && priceCacheConfig.ttlSeconds > 0    ? Math.round(priceCacheConfig.ttlSeconds)    : DEFAULT_PRICE_CACHE_TTL_SECONDS;  const priceCacheCheckPeriodSeconds = Number.isFinite(priceCacheConfig.checkPeriodSeconds)    && priceCacheConfig.checkPeriodSeconds > 0    ? Math.round(priceCacheConfig.checkPeriodSeconds)    : DEFAULT_PRICE_CACHE_CHECK_PERIOD_SECONDS;  configurePriceCache({    ttlSeconds: priceCacheTtlSeconds,    checkPeriodSeconds: priceCacheCheckPeriodSeconds,  });  const priceCacheControlHeader = `private, max-age=${priceCacheTtlSeconds}`;  const maxStaleTradingDays = (() => {    const override = config?.freshness?.maxStaleTradingDays;    if (Number.isFinite(override) && override >= 0) {      return Math.round(override);    }    return DEFAULT_MAX_STALE_TRADING_DAYS;  })();  const dataDirectory = path.resolve(dataDir);  fs.mkdir(dataDirectory, { recursive: true }).catch((error) => {    log.error('failed_to_ensure_data_directory', {      error: error.message,      dataDir: dataDirectory,    });  });  const responseCache = new NodeCache({    stdTTL: cacheTtlSeconds,    checkperiod: Math.max(30, Math.floor(cacheTtlSeconds / 2)),    useClones: false,  });  const priceLogger = typeof log.child === 'function'    ? log.child({ module: 'price_provider' })    : log;  const yahooProvider = new YahooPriceProvider({    fetchImpl,    timeoutMs: fetchTimeoutMs,    logger: priceLogger,  });  const stooqProvider = new StooqPriceProvider({    fetchImpl,    timeoutMs: fetchTimeoutMs,    logger: priceLogger,  });  const compositePriceProvider = new DualPriceProvider({    primary: yahooProvider,    fallback: stooqProvider,    logger: priceLogger,  });  const priceProviderInstance = priceProvider ?? compositePriceProvider;  const portfolioKeyCache = new Map();  const bruteForceConfig = config?.security?.bruteForce ?? {};  configureBruteForce(bruteForceConfig);  function resolveRemoteAddress(req) {    const forwarded = req.headers?.['x-forwarded-for'];    if (typeof forwarded === 'string' && forwarded.trim()) {      return forwarded.split(',')[0].trim();    }    if (Array.isArray(forwarded) && forwarded.length > 0) {      const value = forwarded[0];      if (typeof value === 'string' && value.trim()) {        return value.trim();      }    }    return (      req.ip      ?? req.socket?.remoteAddress      ?? req.connection?.remoteAddress      ?? 'unknown'    );  }  const securityLogger = typeof log.child === 'function'    ? log.child({ module: 'security' })    : log;  function logSecurity(level, event, details = {}) {    const logger = typeof securityLogger?.[level] === 'function'      ? securityLogger[level].bind(securityLogger)      : typeof securityLogger?.info === 'function'        ? securityLogger.info.bind(securityLogger)        : null;    if (logger) {      logger({ event, ...details });    }  }  function resolveFailureContext(portfolioId, req) {    const remoteAddress = resolveRemoteAddress(req);    const normalizedId = typeof portfolioId === 'string' && portfolioId ? portfolioId : 'unknown';    return {      key: `${normalizedId}::${remoteAddress}`,      remoteAddress,    };  }  function validateKeyStrength(rawKey, { action }) {    const result = apiKeySchema.safeParse(rawKey);    if (result.success) {      return { ok: true, issues: [] };    }    const issues = result.error?.issues?.map((issue) => issue.message) ?? [];    logSecurity('warn', 'portfolio_key_weak', { action, issues });    return { ok: false, issues };  }  function createWeakKeyError() {    return createHttpError({      status: 400,      code: 'WEAK_KEY',      message: 'API key does not meet strength requirements',      expose: true,      requirements: API_KEY_REQUIREMENTS,    });  }  function digestPortfolioKey(rawKey) {    return createHash('sha256').update(rawKey).digest();  }  function hashPortfolioKey(rawKey) {    return digestPortfolioKey(rawKey).toString('hex');  }  function normalizeKey(value) {    if (typeof value !== 'string') {      return '';    }    const trimmed = value.trim();    return trimmed.length > 0 ? trimmed : '';  }  async function readPortfolioKeyHash(portfolioId) {    if (portfolioKeyCache.has(portfolioId)) {      return portfolioKeyCache.get(portfolioId);    }    const storage = await getStorage();    const rows = await storage.readTable('portfolio_keys');    const record = rows.find((row) => row.id === portfolioId);    const hash = typeof record?.hash === 'string' ? record.hash : null;    portfolioKeyCache.set(portfolioId, hash);    return hash;  }  async function writePortfolioKeyHash(portfolioId, hash) {    await withLock(`portfolio-key:${portfolioId}`, async () => {      const storage = await getStorage();      if (hash) {        await storage.upsertRow(          'portfolio_keys',          {            id: portfolioId,            hash,            updated_at: new Date().toISOString(),          },          ['id'],        );      } else {        await storage.deleteWhere('portfolio_keys', (row) => row.id === portfolioId);      }    });    portfolioKeyCache.set(portfolioId, hash ?? null);  }  function createPortfolioKeyVerifier({ allowBootstrap = false, allowRotation = false } = {}) {    return async (req, res, next) => {      const { id: portfolioId } = req.params ?? {};      const providedKey = normalizeKey(req.get('x-portfolio-key'));      const rotationKey = normalizeKey(req.get('x-portfolio-key-new'));      const { remoteAddress } = resolveFailureContext(portfolioId, req);      const now = Date.now();      const lockoutStatus = checkBruteForceLockout(portfolioId, remoteAddress, now);      if (lockoutStatus.blocked) {        if (lockoutStatus.retryAfterSeconds) {          res.set('Retry-After', String(lockoutStatus.retryAfterSeconds));        }        logSecurity('warn', 'portfolio_key_lockout', {          id: portfolioId,          remote_address: remoteAddress,          retry_after_seconds: lockoutStatus.retryAfterSeconds ?? null,          lockout_count: lockoutStatus.lockoutCount ?? null,        });        if (typeof req.auditLog === 'function') {          req.auditLog('auth_failed', {            portfolio_id: portfolioId,            reason: 'lockout_active',            retry_after_seconds: lockoutStatus.retryAfterSeconds ?? null,            lockout_count: lockoutStatus.lockoutCount ?? null,          });        }        next(          createHttpError({            status: 429,            code: 'TOO_MANY_KEY_ATTEMPTS',            message: 'Too many invalid portfolio key attempts. Try again later.',            expose: true,          }),        );        return;      }      try {        const storedHash = await readPortfolioKeyHash(portfolioId);        if (!storedHash) {          if (!providedKey) {            next(              createHttpError({                status: 401,                code: 'NO_KEY',                message: 'Portfolio key required.',                expose: true,              }),            );            return;          }          if (!allowBootstrap) {            next(              createHttpError({                status: 404,                code: 'PORTFOLIO_NOT_FOUND',                message: 'Portfolio not provisioned.',              }),            );            return;          }          const { ok: bootstrapKeyOk, issues: bootstrapIssues } = validateKeyStrength(            providedKey,            { action: 'bootstrap' },          );          if (!bootstrapKeyOk) {            if (typeof req.auditLog === 'function') {              req.auditLog('weak_key_rejected', {                portfolio_id: portfolioId,                action: 'bootstrap',                issues: bootstrapIssues,              });            }            next(createWeakKeyError());            return;          }          const hashed = hashPortfolioKey(providedKey);          await writePortfolioKeyHash(portfolioId, hashed);          clearAuthFailures(portfolioId, remoteAddress);          if (!req.portfolioAuth) {            req.portfolioAuth = {};          }          req.portfolioAuth.bootstrapped = true;          logSecurity('info', 'portfolio_key_bootstrapped', { id: portfolioId });          if (typeof req.auditLog === 'function') {            req.auditLog('auth_success', {              portfolio_id: portfolioId,              mode: 'bootstrap',            });          }          next();          return;        }        if (!providedKey) {          const failureResult = registerAuthFailure(portfolioId, remoteAddress, now);          if (failureResult.retryAfterSeconds) {            res.set('Retry-After', String(failureResult.retryAfterSeconds));          }          logSecurity('warn', 'portfolio_key_missing', {            id: portfolioId,            remote_address: remoteAddress,            blocked: failureResult.blocked,            remaining_attempts: failureResult.remainingAttempts ?? null,          });          if (typeof req.auditLog === 'function') {            req.auditLog('auth_failed', {              portfolio_id: portfolioId,              reason: 'missing_key',              blocked: failureResult.blocked,              remaining_attempts: failureResult.remainingAttempts ?? null,            });          }          const error = createHttpError({            status: failureResult.blocked ? 429 : 401,            code: failureResult.blocked ? 'TOO_MANY_KEY_ATTEMPTS' : 'NO_KEY',            message: failureResult.blocked              ? 'Too many missing or invalid portfolio key attempts. Try again later.'              : 'Portfolio key required.',            expose: true,          });          if (!failureResult.blocked && Number.isFinite(failureResult.remainingAttempts)) {            error.details = { remaining_attempts: failureResult.remainingAttempts };          }          next(error);          return;        }        const storedBuffer = Buffer.from(storedHash, 'hex');        const providedDigest = digestPortfolioKey(providedKey);        if (          storedBuffer.length !== providedDigest.length          || !timingSafeEqual(storedBuffer, providedDigest)        ) {          const failureResult = registerAuthFailure(portfolioId, remoteAddress, now);          if (failureResult.retryAfterSeconds) {            res.set('Retry-After', String(failureResult.retryAfterSeconds));          }          const attemptTotal = failureResult.failures ?? failureResult.attempts ?? null;          logSecurity('warn', 'portfolio_key_invalid', {            id: portfolioId,            remote_address: remoteAddress,            blocked: failureResult.blocked,            attempts: attemptTotal,          });          if (failureResult.blocked) {            logSecurity('warn', 'portfolio_key_blocked', {              id: portfolioId,              remote_address: remoteAddress,              retry_after_seconds: failureResult.retryAfterSeconds ?? null,              lockout_count: failureResult.lockoutCount ?? null,            });          }          if (typeof req.auditLog === 'function') {            req.auditLog('auth_failed', {              portfolio_id: portfolioId,              reason: 'invalid_key',              blocked: failureResult.blocked,              attempts: attemptTotal,              remaining_attempts: failureResult.remainingAttempts ?? null,              retry_after_seconds: failureResult.retryAfterSeconds ?? null,            });          }          const error = createHttpError({            status: failureResult.blocked ? 429 : 403,            code: failureResult.blocked ? 'TOO_MANY_KEY_ATTEMPTS' : 'INVALID_KEY',            message: failureResult.blocked              ? 'Too many invalid portfolio key attempts. Try again later.'              : 'Invalid portfolio key.',            expose: true,          });          if (!failureResult.blocked && Number.isFinite(failureResult.remainingAttempts)) {            error.details = { remaining_attempts: failureResult.remainingAttempts };          }          next(error);          return;        }        clearAuthFailures(portfolioId, remoteAddress);        if (allowRotation && rotationKey) {          const { ok: rotationKeyOk, issues: rotationIssues } = validateKeyStrength(            rotationKey,            { action: 'rotate' },          );          if (!rotationKeyOk) {            if (typeof req.auditLog === 'function') {              req.auditLog('weak_key_rejected', {                portfolio_id: portfolioId,                action: 'rotate',                issues: rotationIssues,              });            }            next(createWeakKeyError());            return;          }          const newHash = hashPortfolioKey(rotationKey);          if (newHash !== storedHash) {            await writePortfolioKeyHash(portfolioId, newHash);            clearAuthFailures(portfolioId, remoteAddress);            if (!req.portfolioAuth) {              req.portfolioAuth = {};            }            req.portfolioAuth.rotated = true;            logSecurity('info', 'portfolio_key_rotated', { id: portfolioId });            if (typeof req.auditLog === 'function') {              req.auditLog('key_rotated', {                portfolio_id: portfolioId,              });            }          }        }        if (typeof req.auditLog === 'function') {          req.auditLog('auth_success', {            portfolio_id: portfolioId,            mode: 'access',          });        }        next();      } catch (error) {        logSecurity('error', 'portfolio_key_verification_failed', {          id: portfolioId,          error: error.message,        });        if (typeof req.auditLog === 'function') {          req.auditLog('auth_failed', {            portfolio_id: portfolioId,            reason: 'verification_error',          });        }        next(          createHttpError({            status: 500,            code: 'KEY_VERIFICATION_FAILED',            message: 'Failed to verify portfolio key.',            expose: false,          }),        );      }    };  }  function resolvePortfolioFilePath(portfolioId) {    const candidate = path.resolve(dataDirectory, `portfolio_${portfolioId}.json`);    const relative = path.relative(dataDirectory, candidate);    if (relative.startsWith('..') || path.isAbsolute(relative)) {      throw createHttpError({        status: 400,        code: 'INVALID_PORTFOLIO_ID',        message: 'Invalid portfolio identifier.',        expose: true,      });    }    return candidate;  }  function ensureTransactionUids(transactions, portfolioId) { const seen = new Set(); const deduplicated = []; const duplicates = new Set(); let timestampCursor = 0; let seqCursor = -1; for (const transaction of transactions) { const base = transaction && typeof transaction === 'object' ? transaction : {}; const rawUid = typeof base.uid === 'string' ? base.uid.trim() : ''; const uid = rawUid ? rawUid : randomUUID(); if (seen.has(uid)) { duplicates.add(uid); continue; } seen.add(uid); let numericCreatedAt = Number.NaN; if (typeof base.createdAt === 'number') { numericCreatedAt = Number.isFinite(base.createdAt) ? Math.trunc(base.createdAt) : Number.NaN; } else if (typeof base.createdAt === 'string') { const trimmed = base.createdAt.trim(); if (trimmed !== '') { const parsed = Number.parseInt(trimmed, 10); numericCreatedAt = Number.isNaN(parsed) ? Number.NaN : parsed; } } let createdAt = Number.isFinite(numericCreatedAt) && numericCreatedAt >= 0 ? numericCreatedAt : Date.now(); if (createdAt <= timestampCursor) { createdAt = timestampCursor + 1; } timestampCursor = createdAt; let numericSeq = Number.NaN; if (typeof base.seq === 'number') { numericSeq = Number.isFinite(base.seq) ? Math.trunc(base.seq) : Number.NaN; } else if (typeof base.seq === 'string') { const trimmedSeq = base.seq.trim(); if (trimmedSeq !== '') { const parsedSeq = Number.parseInt(trimmedSeq, 10); numericSeq = Number.isNaN(parsedSeq) ? Number.NaN : parsedSeq; } } let seq = Number.isInteger(numericSeq) && numericSeq >= 0 ? numericSeq : seqCursor + 1; if (seq <= seqCursor) { seq = seqCursor + 1; } seqCursor = seq; deduplicated.push({ ...base, uid, createdAt, seq }); } if (duplicates.size > 0) { log.warn('duplicate_transaction_uids_filtered', { id: portfolioId, duplicates: Array.from(duplicates), }); } return deduplicated; }
function enforceNonNegativeCash(transactions, { portfolioId, logger }) {
  if (!Array.isArray(transactions) || transactions.length === 0) {
    return;
  }
  const normalizeCurrencyCode = (value) => {
    if (typeof value !== 'string') {
      return 'USD';
    }
    const normalized = value.trim().toUpperCase();
    return /^[A-Z]{3}$/u.test(normalized) ? normalized : 'USD';
  };
  const sorted = sortTransactions(transactions);
  const cashByCurrency = new Map();
  for (const tx of sorted) {
    if (!tx || typeof tx !== 'object') {
      continue;
    }
    const amount = Number.parseFloat(tx.amount ?? 0);
    if (!Number.isFinite(amount)) {
      continue;
    }
    const cents = Math.abs(toCents(amount));
    const currency = normalizeCurrencyCode(tx.currency);
    const previousCents = cashByCurrency.get(currency) ?? 0;
    let nextCents = previousCents;
    switch (tx.type) {
      case 'DEPOSIT':
      case 'DIVIDEND':
      case 'INTEREST':
      case 'SELL':
        nextCents += cents;
        break;
      case 'WITHDRAWAL':
      case 'BUY':
      case 'FEE':
        nextCents -= cents;
        break;
      default:
        continue;
    }
    cashByCurrency.set(currency, nextCents);
    if (nextCents < 0) {
      const deficitDecimal = roundDecimal(fromCents(-nextCents), 2);
      const balanceDecimal = roundDecimal(fromCents(previousCents), 2);
      const deficit = deficitDecimal.toNumber();
      const balance = balanceDecimal.toNumber();
      logger?.warn?.('cash_overdraw_rejected', {
        id: portfolioId,
        date: tx.date,
        type: tx.type,
        amount,
        deficit,
        balance,
        currency,
      });
      throw createHttpError({
        status: 400,
        code: 'E_CASH_OVERDRAW',
        message: `Cash balance cannot go negative. Deficit of ${deficitDecimal.toFixed(2)} detected.`,
        details: {
          date: tx.date,
          type: tx.type,
          amount,
          deficit,
          balance,
          currency,
        },
        expose: true,
      });
    }
  }
}
function enforceOversellPolicy(transactions, { portfolioId, autoClip }) {    if (!Array.isArray(transactions) || transactions.length === 0) {      return;    }    const holdingsMicro = new Map();    const ordered = sortTransactions(transactions);    for (const tx of ordered) {      if (!tx || typeof tx !== 'object') {        continue;      }      const ticker = tx.ticker;      if (!ticker || ticker === 'CASH') {        continue;      }      if (tx.type === 'BUY') {        const rawQuantity = Number.isFinite(tx.quantity)          ? tx.quantity          : Number.isFinite(tx.shares)            ? Math.abs(tx.shares)            : 0;        const micro = Math.max(0, toMicroShares(rawQuantity));        if (micro === 0) {          continue;        }        const current = holdingsMicro.get(ticker) ?? 0;        holdingsMicro.set(ticker, current + micro);        continue;      }      if (tx.type !== 'SELL') {        continue;      }      const requestedMicro = Math.abs(        toMicroShares(          Number.isFinite(tx.quantity)            ? tx.quantity            : Number.isFinite(tx.shares)              ? -Math.abs(tx.shares)              : 0,        ),      );      if (requestedMicro === 0) {        continue;      }      const availableMicro = holdingsMicro.get(ticker) ?? 0;      if (requestedMicro <= availableMicro) {        holdingsMicro.set(ticker, availableMicro - requestedMicro);        continue;      }      const requestedShares = roundDecimal(fromMicroShares(requestedMicro), 6).toNumber();      const availableShares = roundDecimal(fromMicroShares(availableMicro), 6).toNumber();      if (!autoClip) {        log.warn('oversell_rejected', {          id: portfolioId,          ticker,          date: tx.date,          requested_shares: requestedShares,          available_shares: availableShares,        });        throw createHttpError({          status: 400,          code: 'E_OVERSELL',          message: `Cannot sell ${requestedShares} shares of ${ticker}. Only ${availableShares} available.`,          details: {            ticker,            requested: requestedShares,            available: availableShares,            date: tx.date,          },          expose: true,        });      }      const clippedMicro = availableMicro;      const clippedSharesDecimal = roundDecimal(fromMicroShares(clippedMicro), 6);      const clippedShares = clippedSharesDecimal.toNumber();      const originalShares = Number.isFinite(tx.shares)        ? Math.abs(tx.shares)        : requestedShares;      let adjustedAmount = 0;      if (originalShares > 0 && Number.isFinite(tx.amount) && tx.amount !== 0) {        const perShare = d(Math.abs(tx.amount)).div(originalShares);        const newAmountDecimal = perShare.times(clippedSharesDecimal);        const signedAmount = tx.amount >= 0 ? newAmountDecimal : newAmountDecimal.neg();        adjustedAmount = roundDecimal(signedAmount, 6).toNumber();      }      if (clippedShares === 0) {        adjustedAmount = 0;      }      tx.quantity = clippedShares === 0 ? 0 : -clippedShares;      tx.shares = clippedShares;      tx.amount = adjustedAmount;      const metadata = tx.metadata && typeof tx.metadata === 'object' ? { ...tx.metadata } : {};      const systemMeta = metadata.system && typeof metadata.system === 'object'        ? { ...metadata.system }        : {};      systemMeta.oversell_clipped = {        requested_shares: requestedShares,        available_shares: availableShares,        delivered_shares: clippedShares,      };      metadata.system = systemMeta;      tx.metadata = metadata;      holdingsMicro.set(ticker, 0);      log.warn('oversell_clipped', {        id: portfolioId,        ticker,        date: tx.date,        requested_shares: requestedShares,        delivered_shares: clippedShares,      });    }  }  let storagePromise;  const getStorage = async () => {    if (!storagePromise) {      storagePromise = runMigrations({ dataDir, logger: log });    }    return storagePromise;  };  const app = express();  app.locals.securityEventStore = securityEventStore;  app.disable('x-powered-by');  const compressionMiddleware = compression({    threshold: 1024,    level: 6,    filter(req, res) {      if (req.headers['x-no-compression']) {        return false;      }      return compression.filter(req, res);    },  });  app.use(compressionMiddleware);  const httpLogger = pinoHttp({    logger: DEFAULT_LOGGER,    genReqId(req) {      return req.headers['x-request-id'] ?? randomUUID();    },    customSuccessMessage() {      return 'request_complete';    },    customErrorMessage() {      return 'request_error';    },  });  app.use(httpLogger);  app.use((req, res, next) => {    const headerRequestId = typeof req.get === 'function' ? req.get('X-Request-ID') : req.headers?.['x-request-id'];    const normalizedRequestId = typeof headerRequestId === 'string' ? headerRequestId.trim().slice(0, 128) : '';    if (normalizedRequestId.length > 0) {      req.id = normalizedRequestId;    } else if (typeof req.id !== 'string' || req.id.length === 0) {      req.id = randomUUID();    }    res.setHeader('X-Request-ID', req.id);    res.locals.requestId = req.id;    next();  });  app.use((req, res, next) => {    if (!(req.originalUrl && req.originalUrl.startsWith('/api/v1'))) {      next();      return;    }    const rewrittenUrl = req.url.replace(/^\/api\/v1(?=\/|$)/u, '/api');    req.url = rewrittenUrl.length === 0 ? '/api' : rewrittenUrl;    req.originalUrl = req.originalUrl.replace(/^\/api\/v1(?=\/|$)/u, '/api');    res.locals.apiVersion = 'v1';    res.setHeader('X-API-Version', 'v1');    next();  });  app.use('/api', (req, res, next) => {    if (!res.locals.apiVersion) {      res.locals.apiVersion = 'legacy';      res.setHeader('Warning', '299 - "Legacy API path /api is deprecated; migrate to /api/v1"');      res.setHeader('X-API-Version', 'legacy');    } else if (!res.getHeader('X-API-Version')) {      res.setHeader('X-API-Version', res.locals.apiVersion);    }    next();  });  app.use(createSecurityAuditLogger({ logger: log, sink: handleSecurityEvent }));  app.use(    helmet({      contentSecurityPolicy: {        useDefaults: true,        directives: {          'default-src': ["'self'"],          'base-uri': ["'self'"],          'script-src': ["'self'"],          'frame-ancestors': ["'none'"],          'connect-src': ["'self'"],        },      },      frameguard: { action: 'deny' },      hsts: { maxAge: 15552000, includeSubDomains: true, preload: true },      referrerPolicy: { policy: 'no-referrer' },    }),  );  const allowedOriginSet = new Set(allowedOrigins);  app.use(    cors({      origin(origin, callback) {        if (!origin) {          callback(null, true);          return;        }        if (allowedOriginSet.has(origin)) {          callback(null, true);          return;        }        callback(          createHttpError({            status: 403,            code: 'CORS_NOT_ALLOWED',            message: 'Origin not allowed by CORS policy',          }),        );      },      methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],      credentials: false,    }),  );  app.use(express.json({ limit: '10mb' }));  const rateLimitConfig = config?.rateLimit ?? {};  const { handler: generalLimitHandler, ...generalLimitConfig } = rateLimitConfig.general ?? {};  const { handler: portfolioLimitHandler, ...portfolioLimitConfig } = rateLimitConfig.portfolio ?? {};  const { handler: priceLimitHandler, ...priceLimitConfig } = rateLimitConfig.prices ?? {};  const generalWindowMs = Number.isFinite(generalLimitConfig.windowMs)    ? Math.max(MIN_RATE_LIMIT_WINDOW_MS, Math.round(generalLimitConfig.windowMs))    : RATE_LIMIT_DEFAULTS.general.windowMs;  const generalMax = Number.isFinite(generalLimitConfig.max)    ? Math.max(MIN_RATE_LIMIT_MAX, Math.round(generalLimitConfig.max))    : RATE_LIMIT_DEFAULTS.general.max;  const portfolioWindowMs = Number.isFinite(portfolioLimitConfig.windowMs)    ? Math.max(MIN_RATE_LIMIT_WINDOW_MS, Math.round(portfolioLimitConfig.windowMs))    : RATE_LIMIT_DEFAULTS.portfolio.windowMs;  const portfolioMax = Number.isFinite(portfolioLimitConfig.max)    ? Math.max(MIN_RATE_LIMIT_MAX, Math.round(portfolioLimitConfig.max))    : RATE_LIMIT_DEFAULTS.portfolio.max;  const priceWindowMs = Number.isFinite(priceLimitConfig.windowMs)    ? Math.max(MIN_RATE_LIMIT_WINDOW_MS, Math.round(priceLimitConfig.windowMs))    : RATE_LIMIT_DEFAULTS.prices.windowMs;  const priceMax = Number.isFinite(priceLimitConfig.max)    ? Math.max(MIN_RATE_LIMIT_MAX, Math.round(priceLimitConfig.max))    : RATE_LIMIT_DEFAULTS.prices.max;  registerRateLimitConfig('general', { limit: generalMax, windowMs: generalWindowMs });  registerRateLimitConfig('portfolio', { limit: portfolioMax, windowMs: portfolioWindowMs });  registerRateLimitConfig('prices', { limit: priceMax, windowMs: priceWindowMs });  const resolveRateLimitIp = (req) => {    const forwarded = req?.headers?.['x-forwarded-for'];    if (typeof forwarded === 'string' && forwarded.trim().length > 0) {      const [first] = forwarded.split(',');      if (first) {        return first.trim();      }    }    if (typeof req?.ip === 'string' && req.ip) {      return req.ip;    }    if (req?.connection?.remoteAddress) {      return req.connection.remoteAddress;    }    if (req?.socket?.remoteAddress) {      return req.socket.remoteAddress;    }    return undefined;  };  const createLimitHandler = ({ scope, limit, windowMs, customHandler }) =>    async (req, res, next, optionsUsed) => {      recordRateLimitHit({        scope,        limit,        windowMs,        ip: resolveRateLimitIp(req),      });      if (typeof req.auditLog === 'function') {        req.auditLog('rate_limit_exceeded', {          scope,          route: req.originalUrl,          limit,          window_ms: windowMs,        });      }      if (typeof customHandler === 'function') {        return customHandler(req, res, next, optionsUsed);      }      res.status(optionsUsed.statusCode);      const message = typeof optionsUsed.message === 'function'        ? await optionsUsed.message(req, res)        : optionsUsed.message;      if (!res.writableEnded) {        res.send(message);      }    };  const generalLimiter = rateLimit({    ...generalLimitConfig,    windowMs: generalWindowMs,    max: generalMax,    standardHeaders: true,    legacyHeaders: false,    handler: createLimitHandler({      scope: 'general',      limit: generalMax,      windowMs: generalWindowMs,      customHandler: generalLimitHandler,    }),  });  const portfolioLimiter = rateLimit({    ...portfolioLimitConfig,    windowMs: portfolioWindowMs,    max: portfolioMax,    standardHeaders: true,    legacyHeaders: false,    handler: createLimitHandler({      scope: 'portfolio',      limit: portfolioMax,      windowMs: portfolioWindowMs,      customHandler: portfolioLimitHandler,    }),  });  app.use('/api', generalLimiter);  app.use(['/api/portfolio', '/api/returns', '/api/nav'], portfolioLimiter);  const priceLimiter = rateLimit({    ...priceLimitConfig,    windowMs: priceWindowMs,    max: priceMax,    standardHeaders: true,    legacyHeaders: false,    handler: createLimitHandler({      scope: 'prices',      limit: priceMax,      windowMs: priceWindowMs,      customHandler: priceLimitHandler,    }),  });  app.use('/api/prices', priceLimiter);  async function fetchHistoricalPrices(symbol, range = '1y') {    if (!SYMBOL_PATTERN.test(symbol)) {      throw createHttpError({        status: 400,        code: 'INVALID_SYMBOL',        message: 'Invalid symbol.',      });    }    const normalizedRange = typeof range === 'string' && range.trim() ? range.trim().toLowerCase() : '1y';    const normalizedSymbol = symbol.trim().toUpperCase();    const cached = getCachedPrice(normalizedSymbol, normalizedRange);    if (cached) {      return { prices: cached.data, etag: cached.etag, cacheHit: true };    }    const today = new Date();    const toDate = toDateKey(today);    let fromDate = '1900-01-01';    if (normalizedRange === '1y') {      const oneYearAgo = new Date(today);      oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);      fromDate = toDateKey(oneYearAgo);    }    try {      const fetched = await priceProviderInstance.getDailyAdjustedClose(        normalizedSymbol,        fromDate,        toDate,      );      const sorted = [...fetched]        .filter((item) => item.date && Number.isFinite(Number(item.adjClose)))        .map((item) => ({ date: item.date, close: Number(item.adjClose) }))        .sort((a, b) => a.date.localeCompare(b.date));      const etag = setCachedPrice(normalizedSymbol, normalizedRange, sorted);      return { prices: sorted, etag, cacheHit: false };    } catch (error) {      if (error.name === 'AbortError') {        const timeoutError = createHttpError({          status: 504,          code: 'UPSTREAM_TIMEOUT',          message: 'Price fetch timed out.',        });        log.error('price_fetch_timeout', {          error: error.message,          symbol,        });        throw timeoutError;      }      log.error('price_fetch_failed', {        error: error.message,        symbol,      });      if (error.statusCode) {        throw error;      }      throw createHttpError({        status: 502,        code: 'PRICE_FETCH_FAILED',        message: 'Failed to fetch historical prices.',        expose: true,      });    }  }  const requirePortfolioKeyRead = createPortfolioKeyVerifier();  const requirePortfolioKeyWrite = createPortfolioKeyVerifier({    allowBootstrap: true,    allowRotation: true,  });  const validatePortfolioId = (req, res, next) => {    validatePortfolioIdParam(req, res, (error) => {      if (error) {        log.warn('invalid_portfolio_id', { id: req.params?.id });        next(error);        return;      }      next();    });  };  app.get('/api/prices/:symbol', async (req, res, next) => {    const { symbol } = req.params;    const { range } = req.query;    try {      const { prices, etag, cacheHit } = await fetchHistoricalPrices(symbol, range ?? '1y');      const latestDate = prices.length > 0 ? prices[prices.length - 1].date : null;      const tradingDayAge = computeTradingDayAge(latestDate);      if (!latestDate || tradingDayAge > maxStaleTradingDays) {        log.warn('stale_price_data', {          symbol,          latest_date: latestDate,          trading_days_age: tradingDayAge,          threshold_trading_days: maxStaleTradingDays,        });        res.status(503).json({ error: 'STALE_DATA' });        return;      }      const clientETag = req.get('if-none-match');      if (cacheHit && clientETag && clientETag === etag) {        res          .status(304)          .set('ETag', etag)          .set('Cache-Control', priceCacheControlHeader)          .set('X-Cache', 'HIT')          .end();        return;      }      res        .set('ETag', etag)        .set('Cache-Control', priceCacheControlHeader)        .set('X-Cache', cacheHit ? 'HIT' : 'MISS')        .json(prices);    } catch (error) {      if (error.statusCode) {        next(error);        return;      }      next(        createHttpError({          status: 502,          code: 'PRICE_FETCH_FAILED',          message: 'Failed to fetch historical prices.',        }),      );    }  });  app.get('/api/cache/stats', (_req, res) => {    res.json(getCacheStats());  });  app.get('/api/security/events', validateSecurityEventsQuery, (req, res) => {    const { limit } = req.query;    res.json({ events: securityEventStore.list({ limit }) });  });  app.get('/api/security/stats', (_req, res) => {    res.json({      bruteForce: getBruteForceStats(),      rateLimit: getRateLimitMetrics(),    });  });  app.get('/api/monitoring', (_req, res) => {    res.json(getPerformanceMetrics());  });  app.get(    '/api/portfolio/:id',    validatePortfolioId,    requirePortfolioKeyRead,    async (req, res, next) => {      const { id } = req.params;      let filePath;      try {        filePath = resolvePortfolioFilePath(id);      } catch (error) {        next(error);        return;      }      try {        const data = await fs.readFile(filePath, 'utf8');        res.json(JSON.parse(data));      } catch (error) {        if (error.code === 'ENOENT') {          res.json({});          return;        }        log.error('portfolio_read_failed', { id, error: error.message });        next(          createHttpError({            status: 500,            code: 'PORTFOLIO_READ_FAILED',            message: 'Failed to load portfolio.',            expose: false,          }),        );      }    },  );  app.post(    '/api/portfolio/:id',    validatePortfolioId,    requirePortfolioKeyWrite,    validatePortfolioBody,    async (req, res, next) => {      const { id } = req.params;      let filePath;      try {        filePath = resolvePortfolioFilePath(id);      } catch (error) {        next(error);        return;      }      const payload = req.body;      const autoClip = Boolean(payload.settings?.autoClip);      const normalizedTransactions = ensureTransactionUids(payload.transactions ?? [], id);      const cashCurrency = typeof payload.cash?.currency === 'string' ? payload.cash.currency : 'USD';      const cashTimeline = Array.isArray(payload.cash?.apyTimeline) ? payload.cash.apyTimeline.map((entry) => ({ from: entry.from, to: entry.to ?? null, apy: Number(entry.apy) })) : [];      try {        enforceNonNegativeCash(normalizedTransactions, { portfolioId: id, logger: log });        enforceOversellPolicy(normalizedTransactions, { portfolioId: id, autoClip });      } catch (error) {        next(error);        return;      }      const normalizedPayload = {        schemaVersion: PORTFOLIO_SCHEMA_VERSION,        transactions: normalizedTransactions,        signals: payload.signals ?? {},        settings: { autoClip },        cash: { currency: cashCurrency, apyTimeline: cashTimeline, version: CASH_POLICY_SCHEMA_VERSION },      };      const serialized = `${JSON.stringify(normalizedPayload, null, 2)}\n`;      try {        await withLock(`portfolio:${id}`, async () => {          await atomicWriteFile(filePath, serialized);        });        res.json({ status: 'ok' });      } catch (error) {        log.error('portfolio_write_failed', { id, error: error.message });        next(          createHttpError({            status: 500,            code: 'PORTFOLIO_WRITE_FAILED',            message: 'Failed to save portfolio.',            expose: false,          }),        );      }    },  );  function ensureCashFeature(req, res, next) {    if (!featureFlags.cashBenchmarks) {      next(        createHttpError({          status: 404,          code: 'CASH_BENCHMARKS_DISABLED',          message: 'Cash benchmarks feature is disabled.',        }),      );      return;    }    next();  }  app.get(    '/api/returns/daily',    ensureCashFeature,    validateReturnsQuery,    async (req, res, next) => {      try {        const { from, to, views, page, perPage } = req.query;        const storage = await getStorage();        const rows = filterRowsByRange(await storage.readTable('returns_daily'), from, to);        const { items, meta } = paginateRows(rows, { page, perPage });        const mapping = {          port: 'r_port',          excash: 'r_ex_cash',          spy: 'r_spy_100',          bench: 'r_bench_blended',        };        const series = {};        for (const view of views) {          const key = mapping[view];          if (!key) {            continue;          }          series[key] = items.map((row) => ({ date: row.date, value: row[key] }));        }        series.r_cash = items.map((row) => ({ date: row.date, value: row.r_cash }));        if (!Object.keys(series).length) {          series.r_port = items.map((row) => ({ date: row.date, value: row.r_port }));        }        const payload = { series, meta };        const cacheKey = [          'returns',          from ?? '',          to ?? '',          views.slice().sort().join(','),          page,          perPage,        ].join(':');        const cached = responseCache.get(cacheKey);        if (cached) {          sendJsonWithEtag(req, res, cached, { cacheControl: cacheControlHeader });          return;        }        responseCache.set(cacheKey, payload);        sendJsonWithEtag(req, res, payload, { cacheControl: cacheControlHeader });      } catch (error) {        next(          createHttpError({            status: error.statusCode ?? 500,            code: 'RETURNS_FETCH_FAILED',            message: 'Failed to fetch returns.',            expose: false,          }),        );      }    },  );  app.get('/api/nav/daily', ensureCashFeature, validateRangeQuery, async (req, res, next) => {    try {      const { from, to, page, perPage } = req.query;      const storage = await getStorage();      const rows = filterRowsByRange(await storage.readTable('nav_snapshots'), from, to);      const { items, meta } = paginateRows(rows, { page, perPage });      const data = items.map((row) => {        const weights = weightsFromState({          nav: row.portfolio_nav,          cash: row.cash_balance,          riskValue: row.risk_assets_value,        });        return {          date: row.date,          portfolio_nav: row.portfolio_nav,          ex_cash_nav: row.ex_cash_nav,          cash_balance: row.cash_balance,          risk_assets_value: row.risk_assets_value,          stale_price: Boolean(row.stale_price),          weights,        };      });      const payload = { data, meta };      const cacheKey = ['nav', from ?? '', to ?? '', page, perPage].join(':');      const cached = responseCache.get(cacheKey);      if (cached) {        sendJsonWithEtag(req, res, cached, { cacheControl: cacheControlHeader });        return;      }      responseCache.set(cacheKey, payload);      sendJsonWithEtag(req, res, payload, { cacheControl: cacheControlHeader });    } catch (error) {      next(        createHttpError({          status: error.statusCode ?? 500,          code: 'NAV_FETCH_FAILED',          message: 'Failed to fetch NAV data.',          expose: false,        }),      );    }  });  app.get('/api/benchmarks/summary', ensureCashFeature, validateRangeQuery, async (req, res, next) => {    try {      const { from, to } = req.query;      const storage = await getStorage();      const cacheKey = ['benchmarks', from ?? '', to ?? ''].join(':');      const [returnsTable, navRows, transactions] = await Promise.all([        storage.readTable('returns_daily'),        storage.readTable('nav_snapshots'),        storage.readTable('transactions'),      ]);      const filteredRows = filterRowsByRange(returnsTable, from, to);      const rows = filteredRows.slice().sort((a, b) => a.date.localeCompare(b.date));      const todayKey = toDateKey(new Date());      let referenceKey = to ? toDateKey(to) : todayKey;      if (referenceKey > todayKey) {        referenceKey = todayKey;      }      const latestDate = rows.length > 0 ? rows[rows.length - 1].date : null;      const referenceDate = new Date(`${referenceKey}T00:00:00Z`);      const tradingDayAge = computeTradingDayAge(latestDate, referenceDate);      if (!latestDate || tradingDayAge > maxStaleTradingDays) {        log.warn('stale_benchmark_data', {          latest_date: latestDate,          reference_date: referenceKey,          trading_days_age: tradingDayAge,          threshold_trading_days: maxStaleTradingDays,        });        res.status(503).json({ error: 'STALE_DATA' });        return;      }      const cached = responseCache.get(cacheKey);      if (cached) {        sendJsonWithEtag(req, res, cached, { cacheControl: cacheControlHeader });        return;      }      const summary = summarizeReturns(rows);      let moneyWeighted = 0;      let moneyWeightedPeriod = { start_date: null, end_date: null };      if (rows.length > 0) {        const startKey = rows[0].date;        const endKey = rows[rows.length - 1].date;        const xirr = computeMoneyWeightedReturn({          transactions,          navRows,          startDate: startKey,          endDate: endKey,        });        moneyWeighted = roundDecimal(xirr, 8).toNumber();        moneyWeightedPeriod = { start_date: startKey, end_date: endKey };      }      const dragVsSelf = Number((summary.r_ex_cash - summary.r_port).toFixed(6));      const allocationDrag = Number(        (summary.r_spy_100 - summary.r_bench_blended).toFixed(6),      );      const payload = {        summary,        drag: {          vs_self: dragVsSelf,          allocation: allocationDrag,        },        money_weighted: {          portfolio: moneyWeighted,          ...moneyWeightedPeriod,          method: 'xirr',        },      };      responseCache.set(cacheKey, payload);      sendJsonWithEtag(req, res, payload, { cacheControl: cacheControlHeader });    } catch (error) {      next(        createHttpError({          status: error.statusCode ?? 500,          code: 'BENCHMARKS_FETCH_FAILED',          message: 'Failed to fetch benchmark summary.',          expose: false,        }),      );    }  });  app.post(    '/api/admin/interest/run',    ensureCashFeature,    validateInterestRunQuery,    async (req, res, next) => {      const requestId = randomUUID();      try {        const { date } = req.query ?? {};        const targetDate = date          ? new Date(`${date}T00:00:00Z`)          : previousTradingDay(new Date());        if (Number.isNaN(targetDate.getTime())) {          next(            createHttpError({              status: 400,              code: 'INVALID_DATE',              message: 'date must be a valid ISO date (YYYY-MM-DD)',              expose: true,            }),          );          return;        }        const result = await runInterestAccrual({          dataDir: dataDirectory,          logger: log,          date: targetDate,          config,          requestId,        });        res.json({ status: 'ok', requestId, result });      } catch (error) {        if (error?.expose) {          next(error);          return;        }        next(          createHttpError({            status: error?.statusCode ?? 500,            code: 'INTEREST_RUN_FAILED',            message: 'Failed to run interest accrual.',            expose: false,          }),        );      }    },  );  app.post(    '/api/admin/interest/backfill',    ensureCashFeature,    validateInterestBackfillQuery,    async (req, res, next) => {      const requestId = randomUUID();      try {        const { from, to } = req.query ?? {};        const result = await runInterestBackfill({          dataDir: dataDirectory,          logger: log,          from,          to,          config,          requestId,        });        res.json({ status: 'ok', requestId, runs: result.runs });      } catch (error) {        if (error?.expose) {          next(error);          return;        }        next(          createHttpError({            status: error?.statusCode ?? 500,            code: 'INTEREST_BACKFILL_FAILED',            message: 'Failed to backfill interest.',            expose: false,          }),        );      }    },  );  app.post(    '/api/admin/cash-rate',    ensureCashFeature,    validateCashRateBody,    async (req, res, next) => {      try {        const { effective_date: effectiveDate, apy } = req.body;        const storage = await getStorage();        await storage.upsertRow(          'cash_rates',          { effective_date: effectiveDate, apy },          ['effective_date'],        );        res.json({ status: 'ok' });      } catch (error) {        next(          createHttpError({            status: error.statusCode ?? 500,            code: 'CASH_RATE_UPSERT_FAILED',            message: 'Failed to update cash rate.',            expose: false,          }),        );      }    },  );  app.use((error, req, res, next) => {    if (res.headersSent) {      next(error);      return;    }    if (error && typeof error === 'object') {      if (error.type === 'entity.too.large') {        error = createHttpError({          status: 413,          code: 'PAYLOAD_TOO_LARGE',          message: 'Request payload too large.',        });      } else if (error.type === 'entity.parse.failed') {        error = createHttpError({          status: 400,          code: 'INVALID_JSON',          message: 'Invalid JSON payload.',          expose: true,        });      }    }    const status = error?.statusCode ?? error?.status ?? 500;    const code = error?.code ?? (status >= 500 ? 'INTERNAL_ERROR' : 'BAD_REQUEST');    let message;    if (status >= 500) {      message = error?.expose ? error?.message ?? 'Unexpected server error' : 'Unexpected server error';    } else if (error?.expose === false) {      message = 'Request could not be processed';    } else {      message = error?.message ?? 'Request could not be processed';    }    const details = status < 500 ? error?.details : undefined;    const logMethod = status >= 500 ? 'error' : 'warn';    const reqLogger = req.log ?? baseLogger;    if (typeof reqLogger?.[logMethod] === 'function') {      reqLogger[logMethod](        {          error: error?.message,          code,          status,          stack: status >= 500 ? error?.stack : undefined,        },        'request_error',      );    }    const responseBody = { error: code, message };    if (details !== undefined) {      responseBody.details = details;    }    if (Array.isArray(error?.requirements) && error.requirements.length > 0) {      responseBody.requirements = error.requirements;    }    res.status(status).json(responseBody);  });  return app;}
